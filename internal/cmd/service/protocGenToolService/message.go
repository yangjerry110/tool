/*
 * @Author: Jerry.Yang
 * @Date: 2025-02-25 10:34:35
 * @LastEditors: Jerry.Yang
 * @LastEditTime: 2025-02-27 14:55:57
 * @Description: message
 */
package protocgentoolservice

import (
	"fmt"
	"os"
	"os/exec"

	"github.com/yangjerry110/tool/internal/cmd/config"
	"google.golang.org/protobuf/compiler/protogen"
)

type Message struct {
	Messages []*protogen.Message
}

/**
 * @description: message Generate
 * @author: Jerry.Yang
 * @date: 2025-02-26 14:36:42
 * @return {*}
 */
func (m *Message) Generate() error {

	// 打开文件
	fileName := fmt.Sprintf("%s/vo/protobuf/%s_messsage.pb.go", config.ProjectPathConf.Path, config.ProtobufFileConf.FileName)
	file, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer file.Close()

	// 写入文件头部信息
	file.WriteString("// Code generated by protoc-gen-tool. DO NOT EDIT.\n")
	file.WriteString(fmt.Sprintf("// Source: %s\n\n", config.ProtobufFileConf.FileName))
	file.WriteString("package protobuf\n\n")

	// for messages
	for _, message := range m.Messages {
		// 为每个 optional 字段生成 Has<Field> 方法并写入文件
		for _, field := range message.Fields {
			if field.Desc.HasOptionalKeyword() {
				if err := CreateProtoGenToolService(&Field{OsFile: file, Message: message, Field: field}).Generate(); err != nil {
					return err
				}
			}
		}
	}

	// 添加一行空行
	file.WriteString("\n\n")

	// 最后确保文件内容被写入
	err = file.Sync()
	if err != nil {
		return err
	}

	cmd := exec.Command("gofmt", "-w", fileName)
	if err := cmd.Run(); err != nil {
		fmt.Printf("\r\n gofmt %s Err : %+v \r\n", fileName, err)
		return err
	}
	return nil
}
